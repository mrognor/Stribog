// Gost: https://rst.gov.ru:8443/file-service/file/load/1699367414693

#include <iostream>
#include <cstdint>
#include <cstring>
#include <fstream>

// Define the block size for working with files
// Must be multiple 64
#define CHUNK_SIZE 4096

/// \brief Constants for the S function of the Stribog algorithm
const unsigned char Pi[256] = {
    0xfc, 0xee, 0xdd, 0x11, 0xcf, 0x6e, 0x31, 0x16, 0xfb, 0xc4, 0xfa, 0xda, 0x23, 0xc5, 0x04, 0x4d,
    0xe9, 0x77, 0xf0, 0xdb, 0x93, 0x2e, 0x99, 0xba, 0x17, 0x36, 0xf1, 0xbb, 0x14, 0xcd, 0x5f, 0xc1,
    0xf9, 0x18, 0x65, 0x5a, 0xe2, 0x5c, 0xef, 0x21, 0x81, 0x1c, 0x3c, 0x42, 0x8b, 0x01, 0x8e, 0x4f,
    0x05, 0x84, 0x02, 0xae, 0xe3, 0x6a, 0x8f, 0xa0, 0x06, 0x0b, 0xed, 0x98, 0x7f, 0xd4, 0xd3, 0x1f,
    0xeb, 0x34, 0x2c, 0x51, 0xea, 0xc8, 0x48, 0xab, 0xf2, 0x2a, 0x68, 0xa2, 0xfd, 0x3a, 0xce, 0xcc,
    0xb5, 0x70, 0x0e, 0x56, 0x08, 0x0c, 0x76, 0x12, 0xbf, 0x72, 0x13, 0x47, 0x9c, 0xb7, 0x5d, 0x87,
    0x15, 0xa1, 0x96, 0x29, 0x10, 0x7b, 0x9a, 0xc7, 0xf3, 0x91, 0x78, 0x6f, 0x9d, 0x9e, 0xb2, 0xb1,
    0x32, 0x75, 0x19, 0x3d, 0xff, 0x35, 0x8a, 0x7e, 0x6d, 0x54, 0xc6, 0x80, 0xc3, 0xbd, 0x0d, 0x57,
    0xdf, 0xf5, 0x24, 0xa9, 0x3e, 0xa8, 0x43, 0xc9, 0xd7, 0x79, 0xd6, 0xf6, 0x7c, 0x22, 0xb9, 0x03,
    0xe0, 0x0f, 0xec, 0xde, 0x7a, 0x94, 0xb0, 0xbc, 0xdc, 0xe8, 0x28, 0x50, 0x4e, 0x33, 0x0a, 0x4a,
    0xa7, 0x97, 0x60, 0x73, 0x1e, 0x00, 0x62, 0x44, 0x1a, 0xb8, 0x38, 0x82, 0x64, 0x9f, 0x26, 0x41,
    0xad, 0x45, 0x46, 0x92, 0x27, 0x5e, 0x55, 0x2f, 0x8c, 0xa3, 0xa5, 0x7d, 0x69, 0xd5, 0x95, 0x3b,
    0x07, 0x58, 0xb3, 0x40, 0x86, 0xac, 0x1d, 0xf7, 0x30, 0x37, 0x6b, 0xe4, 0x88, 0xd9, 0xe7, 0x89,
    0xe1, 0x1b, 0x83, 0x49, 0x4c, 0x3f, 0xf8, 0xfe, 0x8d, 0x53, 0xaa, 0x90, 0xca, 0xd8, 0x85, 0x61,
    0x20, 0x71, 0x67, 0xa4, 0x2d, 0x2b, 0x09, 0x5b, 0xcb, 0x9b, 0x25, 0xd0, 0xbe, 0xe5, 0x6c, 0x52,
    0x59, 0xa6, 0x74, 0xd2, 0xe6, 0xf4, 0xb4, 0xc0, 0xd1, 0x66, 0xaf, 0xc2, 0x39, 0x4b, 0x63, 0xb6
};

/// \brief Constants for the L function of the Stribog algorithm
const std::uint64_t A[64] = {
    0x8e20faa72ba0b470, 0x47107ddd9b505a38, 0xad08b0e0c3282d1c, 0xd8045870ef14980e,
    0x6c022c38f90a4c07, 0x3601161cf205268d, 0x1b8e0b0e798c13c8, 0x83478b07b2468764,
    0xa011d380818e8f40, 0x5086e740ce47c920, 0x2843fd2067adea10, 0x14aff010bdd87508,
    0x0ad97808d06cb404, 0x05e23c0468365a02, 0x8c711e02341b2d01, 0x46b60f011a83988e,
    0x90dab52a387ae76f, 0x486dd4151c3dfdb9, 0x24b86a840e90f0d2, 0x125c354207487869,
    0x092e94218d243cba, 0x8a174a9ec8121e5d, 0x4585254f64090fa0, 0xaccc9ca9328a8950,
    0x9d4df05d5f661451, 0xc0a878a0a1330aa6, 0x60543c50de970553, 0x302a1e286fc58ca7,
    0x18150f14b9ec46dd, 0x0c84890ad27623e0, 0x0642ca05693b9f70, 0x0321658cba93c138,
    0x86275df09ce8aaa8, 0x439da0784e745554, 0xafc0503c273aa42a, 0xd960281e9d1d5215,
    0xe230140fc0802984, 0x71180a8960409a42, 0xb60c05ca30204d21, 0x5b068c651810a89e,
    0x456c34887a3805b9, 0xac361a443d1c8cd2, 0x561b0d22900e4669, 0x2b838811480723ba,
    0x9bcf4486248d9f5d, 0xc3e9224312c8c1a0, 0xeffa11af0964ee50, 0xf97d86d98a327728,
    0xe4fa2054a80b329c, 0x727d102a548b194e, 0x39b008152acb8227, 0x9258048415eb419d,
    0x492c024284fbaec0, 0xaa16012142f35760, 0x550b8e9e21f7a530, 0xa48b474f9ef5dc18,
    0x70a6a56e2440598e, 0x3853dc371220a247, 0x1ca76e95091051ad, 0x0edd37c48a08a6d8,
    0x07e095624504536c, 0x8d70c431ac02a736, 0xc83862965601dd1b, 0x641c314b2b8ee083
};

/// \brief Constants for key expansion in the Stribog algorithm
const unsigned char C[12][64] = {
    {
        0x07, 0x45, 0xa6, 0xf2, 0x59, 0x65, 0x80, 0xdd,
        0x23, 0x4d, 0x74, 0xcc, 0x36, 0x74, 0x76, 0x05,
        0x15, 0xd3, 0x60, 0xa4, 0x08, 0x2a, 0x42, 0xa2,
        0x01, 0x69, 0x67, 0x92, 0x91, 0xe0, 0x7c, 0x4b,
        0xfc, 0xc4, 0x85, 0x75, 0x8d, 0xb8, 0x4e, 0x71,
        0x16, 0xd0, 0x45, 0x2e, 0x43, 0x76, 0x6a, 0x2f,
        0x1f, 0x7c, 0x65, 0xc0, 0x81, 0x2f, 0xcb, 0xeb,
        0xe9, 0xda, 0xca, 0x1e, 0xda, 0x5b, 0x08, 0xb1
    },
    {
        0xb7, 0x9b, 0xb1, 0x21, 0x70, 0x04, 0x79, 0xe6,
        0x56, 0xcd, 0xcb, 0xd7, 0x1b, 0xa2, 0xdd, 0x55,
        0xca, 0xa7, 0x0a, 0xdb, 0xc2, 0x61, 0xb5, 0x5c,
        0x58, 0x99, 0xd6, 0x12, 0x6b, 0x17, 0xb5, 0x9a,
        0x31, 0x01, 0xb5, 0x16, 0x0f, 0x5e, 0xd5, 0x61,
        0x98, 0x2b, 0x23, 0x0a, 0x72, 0xea, 0xfe, 0xf3,
        0xd7, 0xb5, 0x70, 0x0f, 0x46, 0x9d, 0xe3, 0x4f,
        0x1a, 0x2f, 0x9d, 0xa9, 0x8a, 0xb5, 0xa3, 0x6f
    },
    {
        0xb2, 0x0a, 0xba, 0x0a, 0xf5, 0x96, 0x1e, 0x99,
        0x31, 0xdb, 0x7a, 0x86, 0x43, 0xf4, 0xb6, 0xc2,
        0x09, 0xdb, 0x62, 0x60, 0x37, 0x3a, 0xc9, 0xc1,
        0xb1, 0x9e, 0x35, 0x90, 0xe4, 0x0f, 0xe2, 0xd3,
        0x7b, 0x7b, 0x29, 0xb1, 0x14, 0x75, 0xea, 0xf2,
        0x8b, 0x1f, 0x9c, 0x52, 0x5f, 0x5e, 0xf1, 0x06,
        0x35, 0x84, 0x3d, 0x6a, 0x28, 0xfc, 0x39, 0x0a,
        0xc7, 0x2f, 0xce, 0x2b, 0xac, 0xdc, 0x74, 0xf5
    },
    {
        0x2e, 0xd1, 0xe3, 0x84, 0xbc, 0xbe, 0x0c, 0x22,
        0xf1, 0x37, 0xe8, 0x93, 0xa1, 0xea, 0x53, 0x34,
        0xbe, 0x03, 0x52, 0x93, 0x33, 0x13, 0xb7, 0xd8,
        0x75, 0xd6, 0x03, 0xed, 0x82, 0x2c, 0xd7, 0xa9,
        0x3f, 0x35, 0x5e, 0x68, 0xad, 0x1c, 0x72, 0x9d,
        0x7d, 0x3c, 0x5c, 0x33, 0x7e, 0x85, 0x8e, 0x48,
        0xdd, 0xe4, 0x71, 0x5d, 0xa0, 0xe1, 0x48, 0xf9,
        0xd2, 0x66, 0x15, 0xe8, 0xb3, 0xdf, 0x1f, 0xef
    },
    {
        0x57, 0xfe, 0x6c, 0x7c, 0xfd, 0x58, 0x17, 0x60,
        0xf5, 0x63, 0xea, 0xa9, 0x7e, 0xa2, 0x56, 0x7a,
        0x16, 0x1a, 0x27, 0x23, 0xb7, 0x00, 0xff, 0xdf,
        0xa3, 0xf5, 0x3a, 0x25, 0x47, 0x17, 0xcd, 0xbf,
        0xbd, 0xff, 0x0f, 0x80, 0xd7, 0x35, 0x9e, 0x35,
        0x4a, 0x10, 0x86, 0x16, 0x1f, 0x1c, 0x15, 0x7f,
        0x63, 0x23, 0xa9, 0x6c, 0x0c, 0x41, 0x3f, 0x9a,
        0x99, 0x47, 0x47, 0xad, 0xac, 0x6b, 0xea, 0x4b
    },
    {
        0x6e, 0x7d, 0x64, 0x46, 0x7a, 0x40, 0x68, 0xfa,
        0x35, 0x4f, 0x90, 0x36, 0x72, 0xc5, 0x71, 0xbf,
        0xb6, 0xc6, 0xbe, 0xc2, 0x66, 0x1f, 0xf2, 0x0a,
        0xb4, 0xb7, 0x9a, 0x1c, 0xb7, 0xa6, 0xfa, 0xcf,
        0xc6, 0x8e, 0xf0, 0x9a, 0xb4, 0x9a, 0x7f, 0x18,
        0x6c, 0xa4, 0x42, 0x51, 0xf9, 0xc4, 0x66, 0x2d,
        0xc0, 0x39, 0x30, 0x7a, 0x3b, 0xc3, 0xa4, 0x6f,
        0xd9, 0xd3, 0x3a, 0x1d, 0xae, 0xae, 0x4f, 0xae
    },
    {
        0x93, 0xd4, 0x14, 0x3a, 0x4d, 0x56, 0x86, 0x88,
        0xf3, 0x4a, 0x3c, 0xa2, 0x4c, 0x45, 0x17, 0x35,
        0x04, 0x05, 0x4a, 0x28, 0x83, 0x69, 0x47, 0x06,
        0x37, 0x2c, 0x82, 0x2d, 0xc5, 0xab, 0x92, 0x09,
        0xc9, 0x93, 0x7a, 0x19, 0x33, 0x3e, 0x47, 0xd3,
        0xc9, 0x87, 0xbf, 0xe6, 0xc7, 0xc6, 0x9e, 0x39,
        0x54, 0x09, 0x24, 0xbf, 0xfe, 0x86, 0xac, 0x51,
        0xec, 0xc5, 0xaa, 0xee, 0x16, 0x0e, 0xc7, 0xf4
    },
    {
        0x1e, 0xe7, 0x02, 0xbf, 0xd4, 0x0d, 0x7f, 0xa4,
        0xd9, 0xa8, 0x51, 0x59, 0x35, 0xc2, 0xac, 0x36,
        0x2f, 0xc4, 0xa5, 0xd1, 0x2b, 0x8d, 0xd1, 0x69,
        0x90, 0x06, 0x9b, 0x92, 0xcb, 0x2b, 0x89, 0xf4,
        0x9a, 0xc4, 0xdb, 0x4d, 0x3b, 0x44, 0xb4, 0x89,
        0x1e, 0xde, 0x36, 0x9c, 0x71, 0xf8, 0xb7, 0x4e,
        0x41, 0x41, 0x6e, 0x0c, 0x02, 0xaa, 0xe7, 0x03,
        0xa7, 0xc9, 0x93, 0x4d, 0x42, 0x5b, 0x1f, 0x9b
    },
    {
        0xdb, 0x5a, 0x23, 0x83, 0x51, 0x44, 0x61, 0x72,
        0x60, 0x2a, 0x1f, 0xcb, 0x92, 0xdc, 0x38, 0x0e,
        0x54, 0x9c, 0x07, 0xa6, 0x9a, 0x8a, 0x2b, 0x7b,
        0xb1, 0xce, 0xb2, 0xdb, 0x0b, 0x44, 0x0a, 0x80,
        0x84, 0x09, 0x0d, 0xe0, 0xb7, 0x55, 0xd9, 0x3c,
        0x24, 0x42, 0x89, 0x25, 0x1b, 0x3a, 0x7d, 0x3a,
        0xde, 0x5f, 0x16, 0xec, 0xd8, 0x9a, 0x4c, 0x94,
        0x9b, 0x22, 0x31, 0x16, 0x54, 0x5a, 0x8f, 0x37
    },
    {
        0xed, 0x9c, 0x45, 0x98, 0xfb, 0xc7, 0xb4, 0x74,
        0xc3, 0xb6, 0x3b, 0x15, 0xd1, 0xfa, 0x98, 0x36,
        0xf4, 0x52, 0x76, 0x3b, 0x30, 0x6c, 0x1e, 0x7a,
        0x4b, 0x33, 0x69, 0xaf, 0x02, 0x67, 0xe7, 0x9f,
        0x03, 0x61, 0x33, 0x1b, 0x8a, 0xe1, 0xff, 0x1f,
        0xdb, 0x78, 0x8a, 0xff, 0x1c, 0xe7, 0x41, 0x89,
        0xf3, 0xf3, 0xe4, 0xb2, 0x48, 0xe5, 0x2a, 0x38,
        0x52, 0x6f, 0x05, 0x80, 0xa6, 0xde, 0xbe, 0xab
    },
    {
        0x1b, 0x2d, 0xf3, 0x81, 0xcd, 0xa4, 0xca, 0x6b,
        0x5d, 0xd8, 0x6f, 0xc0, 0x4a, 0x59, 0xa2, 0xde,
        0x98, 0x6e, 0x47, 0x7d, 0x1d, 0xcd, 0xba, 0xef,
        0xca, 0xb9, 0x48, 0xea, 0xef, 0x71, 0x1d, 0x8a,
        0x79, 0x66, 0x84, 0x14, 0x21, 0x80, 0x01, 0x20,
        0x61, 0x07, 0xab, 0xeb, 0xbb, 0x6b, 0xfa, 0xd8,
        0x94, 0xfe, 0x5a, 0x63, 0xcd, 0xc6, 0x02, 0x30,
        0xfb, 0x89, 0xc8, 0xef, 0xd0, 0x9e, 0xcd, 0x7b
    },
    {
        0x20, 0xd7, 0x1b, 0xf1, 0x4a, 0x92, 0xbc, 0x48,
        0x99, 0x1b, 0xb2, 0xd9, 0xd5, 0x17, 0xf4, 0xfa,
        0x52, 0x28, 0xe1, 0x88, 0xaa, 0xa4, 0x1d, 0xe7,
        0x86, 0xcc, 0x91, 0x18, 0x9d, 0xef, 0x80, 0x5d,
        0x9b, 0x9f, 0x21, 0x30, 0xd4, 0x12, 0x20, 0xf8,
        0x77, 0x1d, 0xdf, 0xbc, 0x32, 0x3c, 0xa4, 0xcd,
        0x7a, 0xb1, 0x49, 0x04, 0xb0, 0x80, 0x13, 0xd2,
        0xba, 0x31, 0x16, 0xf1, 0x67, 0xe7, 0x8e, 0x37
    }
};

/// \brief Convert char to string with hex form of this number
/// \param [in] a char number to convert
/// \return hex represenation of a
std::string CharToHexForm(const char& a) noexcept
{
    std::string res(2, 0);

    std::uint8_t highByte = static_cast<unsigned char>(a) >> 4;
    std::uint8_t lowByte = a & 0b00001111;

    if (highByte > 9)
        res[0] = 'a' + highByte - 10;
    else
        res[0] = highByte + '0';

    if (lowByte > 9)
        res[1] = 'a' + lowByte - 10;
    else
        res[1] = lowByte + '0';

    return res;
}

/**
    \brief A method for adding two arrays

    Arrays of 64 bytes are interpreted as 512 bit numbers and added modulo 512 bits

    \param [in, out] a a pointer to the 64 byte array to which another array will be added. The result after calling the function will be stored with the same pointer
    \param [in] b a pointer to the 64 byte array to be added
*/
inline void StribogAdd512(char *a, const char *b)
{
    int internal = 0;
    for (int i = 0; i < 64; ++i)
    {
        // Summ 2 new bytes and data from previous summ.
        // Example: 250 + 10 = 260.In bits: 0001 0000 0100.
        // 0000 0100 will be saved in current step, 0001 will be added in next iteration
        internal = static_cast<unsigned char>(a[i]) + static_cast<unsigned char>(b[i]) + (internal >> 8);
        a[i] = internal & 0xff;
    }
}

/**
    \brief A method for adding an array with a number modulo 512

    \param [in, out] a a pointer to a 64-byte array to add a number to
    \param [in] b the number to add to the array
*/
inline void StribogAdd512(char *a, int c)
{
    int internal = 0;
    for (int i = 0; i < 64; ++i)
    {
        internal = static_cast<unsigned char>(a[i]) + (c & 0xff) + (internal >> 8);
        c >>= 8;
        a[i] = internal & 0xff;
    }
}

/**
    \brief A method for xor two arrays

    \param [out] dest a pointer to the 64 byte array to which the result will be written
    \param [in] a a pointer to a 64 byte array that needs to be xor
    \param [in] b a pointer to a 64 byte array that needs to be xor
*/
inline void StribogXor(char* dest, const char* a, const char* b)
{
    for (int i = 0; i < 64; ++i) dest[i] = a[i] ^ b[i];
}

/**
    \brief A function for finding padding in the Stribog algorithm

    \param [out] m a pointer to a 64 byte array in which to save the result
    \param [in] data a pointer to an array of source data
    \param [in] dataLen length of the data array
*/
inline void StribogPadding(char* m, const char* data, const std::size_t& dataLen)
{
    memcpy(m, data, dataLen);
    m[dataLen] = 1;
    memset(m + dataLen + 1, 0, 63 - dataLen);
}

/// \brief The S function of the Stribog algorithm
/// \param [in, out] a a pointer to a 64-byte array. The result of the operation will be recorded in it
inline void StribogS(char* a)
{
    for (int i = 0; i < 64; ++i) a[i] = Pi[static_cast<unsigned char>(a[i])];
}

/// \brief The P function of the Stribog algorithm
/// \param [in, out] a a pointer to a 64-byte array. The result of the operation will be recorded in it
inline void StribogP(char* a)
{
    for (int i = 0; i < 8; ++i)
        for (int j = i + 1; j < 8; ++j)
            std::swap(a[i * 8 + j], a[j * 8 + i]);
}

/// \brief The L function of the Stribog algorithm
/// \param [in, out] a a pointer to a 64-byte array. The result of the operation will be recorded in it
inline void StribogL(char* a)
{
    for (int i = 63; i > 0; i -= 8)
    {
        std::uint64_t stateChunkOut = 0;
        std::uint64_t stateChunkIn = (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i])) << 56) |
            (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 1])) << 48) |
            (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 2])) << 40) |
            (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 3])) << 32) |
            (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 4])) << 24) |
            (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 5])) << 16) |
            (static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 6])) << 8) |
            static_cast<std::uint64_t>(static_cast<unsigned char>(a[i - 7]));

        for (int j = 0; j < 64; ++j)
            if ((stateChunkIn >> j) & 1)
                stateChunkOut ^= A[63 - j];

        for (int j = 0; j < 8; ++j)
        {
            a[i - 7 + j] = static_cast<unsigned char>(stateChunkOut & 0b11111111);
            stateChunkOut >>= 8;
        }
    }
}

/// \brief Function for adding a round key
/// \param [in, out] a a pointer to a 64-byte array. The result of the operation will be recorded in it
/// \param [in] i index of the round key
inline void StribogXorKey(char* a, const int& i)
{
    for (int j = 0; j < 64; ++j) a[j] = a[j] ^ C[i][j];

    StribogS(a);
    StribogP(a);
    StribogL(a);
}

/// \brief The E function of the Stribog algorithm
/// \param [in, out] a a pointer to a 64-byte array. The result of the operation will be recorded in it
/// \param [in] a pointer to a 64-byte array
void StribogE(char* k, const char* m)
{
    char state[64];

    StribogXor(state, k, m);

    for (int i = 0; i < 12; ++i)
    {
        StribogS(state);
        StribogP(state);
        StribogL(state);

        StribogXorKey(k, i);

        StribogXor(state, state, k);
    }
    
    memcpy(k, state, 64);
}

/**
    \brief The G function of the Stribog algorithm

    \param [out] dest a pointer to a 64-byte array. The result of the operation will be recorded in it
    \param [in] n pointer to a 64-byte array
    \param [in] h pointer to a 64-byte array
    \param [in] m pointer to a 64-byte array
*/
void StribogG(char* dest, const char* n, const char* h, const char* m)
{
    char state[64];

    if (n != nullptr) StribogXor(state, n, h);
    else memcpy(state, h, 64);

    StribogS(state);
    StribogP(state);
    StribogL(state);

    StribogE(state, m);

    StribogXor(state, state, h);
    StribogXor(dest, state, m);
}

std::string HashStribog(const char* data, std::size_t dataLen, const bool& is256)
{
    char h[64], n[64] = {0}, sig[64] = {0}, m[64];
    if (is256) memset(h, 1, 64);
    else memset(h, 0, 64);

    // Check if data longer then 64
    if (dataLen >= 64)
    {
        // Handle all blocks except last
        for (std::size_t i = 0; i < dataLen >> 6; ++i)
        {
            StribogG(h, n, h, data + (i << 6));
            StribogAdd512(n, 512);
            StribogAdd512(sig, data + (i << 6));
        }
    }

    StribogPadding(m, data + (dataLen & ~0b00111111), dataLen & 0b00111111);
    StribogG(h, n, h, m);
    StribogAdd512(n, (dataLen << 3) & 0b111111111);
    StribogAdd512(sig, m);
    StribogG(h, nullptr, h, n);
    StribogG(h, nullptr, h, sig);

    std::string res;
    if (is256) for (int i = 0; i < 32; ++i) res += CharToHexForm(h[i]);
    else for (int i = 0; i < 64; ++i) res += CharToHexForm(h[i]);
    return res;
}

std::string HashFileStribog(std::ifstream& file, const bool& is256)
{
    char h[64], n[64] = {0}, sig[64] = {0}, m[64];
    if (is256) memset(h, 1, 64);
    else memset(h, 0, 64);

    // Save file size
    uint64_t fileSize = file.tellg();
    file.seekg(0);

    // Arrays to read 4kb from file and to save 4 kb to file
    char fileDataChunk[CHUNK_SIZE];

    // Counter for file reading
    std::size_t counter = 0;

    // Checking whether the file is larger than the size of the file processing chunks
    if (fileSize > CHUNK_SIZE)
    {
        // Processing the part of the file that is a multiple of the chunk size
        for(; counter < fileSize - CHUNK_SIZE; counter += CHUNK_SIZE)
        {
            // Read chunk from input file
            file.read(fileDataChunk, CHUNK_SIZE);

            // Calculate hash steps
            for (std::size_t i = 0; i < CHUNK_SIZE >> 6; i += 1)
            {
                StribogG(h, n, h, fileDataChunk + (i << 6));
                StribogAdd512(n, 512);
                StribogAdd512(sig, fileDataChunk + (i << 6));
            }
        }
    }

    // Calculating the remaining bytes in the file
    counter = fileSize - counter;

    // Read last bytes from input file
    file.read(fileDataChunk, counter);

    // Calculate hash for last bytes
    for (uint64_t i = 0; i < counter >> 6; ++i)
    {
        StribogG(h, n, h, fileDataChunk + (i << 6));
        StribogAdd512(n, 512);
        StribogAdd512(sig, fileDataChunk + (i << 6));
    }

    // Padding source file
    // Move fileDataChunk ptr to last position multiply by 64
    char padding[128];
    StribogPadding(m, fileDataChunk + (counter & ~0b00111111), counter & 0b00111111);  ;
    StribogG(h, n, h, m);
    StribogAdd512(n, (counter << 3) & 0b111111111);
    StribogAdd512(sig, m);
    StribogG(h, nullptr, h, n);
    StribogG(h, nullptr, h, sig);

    std::string res;
    if (is256) for (int i = 0; i < 32; ++i) res += CharToHexForm(h[i]);
    else for (int i = 0; i < 64; ++i) res += CharToHexForm(h[i]);
    return res;
}

std::string Stribog512(const char* data, std::size_t dataLen)
{
    return HashStribog(data, dataLen, false);
}

std::string Stribog512(const std::string& str)
{
    return HashStribog(str.c_str(), str.length(), false);
}

std::string FileStribog512(const std::string fileName)
{
    // Open file
    std::ifstream file(fileName, std::ios_base::binary | std::ios_base::ate);
    if (!file.is_open()) {std::cerr << "Can not open file: " << fileName << std::endl; return "";}

    return HashFileStribog(file, false);
}

std::string Stribog256(const char* data, std::size_t dataLen)
{
    return HashStribog(data, dataLen, true);
}

std::string Stribog256(const std::string& str)
{
    return HashStribog(str.c_str(), str.length(), true);
}

std::string FileStribog256(const std::string fileName)
{
    // Open file
    std::ifstream file(fileName, std::ios_base::binary | std::ios_base::ate);
    if (!file.is_open()) {std::cerr << "Can not open file: " << fileName << std::endl; return "";}

    return HashFileStribog(file, true);
}

int main()
{
    std::cout << Stribog512("test") << std::endl;
    std::cout << FileStribog512("file") << std::endl;

    std::cout << Stribog256("test") << std::endl;
    std::cout << FileStribog256("file") << std::endl;
}